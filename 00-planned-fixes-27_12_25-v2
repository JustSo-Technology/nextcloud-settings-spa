
╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌
 Plan: Convert Nextcloud Settings to SPA

 Fork: https://github.com/JustSo-Technology/nextcloud-settings-spa
 Goal: Convert Personal and Admin settings pages to a Vue SPA with client-side routing (like the Apps page already does)

 Current Architecture

 How It Works Now (Personal/Admin Settings)

 - Template: settings/frame.php - server-renders navigation + content
 - Controllers: PersonalSettingsController / AdminSettingsController use CommonSettingsTrait
 - Each page load: Full HTTP request, PHP renders HTML, Vue components mount to placeholders
 - Navigation: Regular <a href> links cause full page reloads

 How Apps Page Works (Reference SPA)

 - Template: settings/empty.php - nearly empty, Vue takes over #content
 - Controller: AppSettingsController.viewApps() provides InitialState, returns empty template
 - Vue Router: Handles /settings/apps/{category}/{id} client-side
 - Navigation: Vue Router intercepts, no page reloads

 Implementation Plan

 Phase 1: Setup Development Environment

 1. Clone fork and set up Nextcloud dev environment
 2. Ensure build tools work (npm install, npm run dev)
 3. Create feature branch feature/settings-spa

Phase 2: Create Settings SPA Vue App

Technical Stack:
- Vue 2 (matches existing Nextcloud settings app)
- Vue Router 3 (not Vue Router 4)
- Vuex + Pinia (both used in existing codebase - use Vuex for router sync, Pinia for new state)
- TypeScript/JavaScript (follow existing patterns)

New files to create in apps/settings/src/:

src/
├── main-settings.ts              # Entry point for settings SPA (TypeScript)
├── SettingsApp.vue               # Root component with router-view (reuse pattern from main-apps-users-management.ts)
├── router/
│   └── settings-routes.ts        # Vue Router routes configuration (add to existing routes.ts)
├── store/
│   └── settings-store.ts         # Pinia store for settings state (cache sections/content)
├── views/
│   ├── PersonalSettings.vue      # Personal settings container
│   ├── AdminSettings.vue         # Admin settings container
│   └── SettingsSection.vue       # Generic section renderer (handles both types)
├── components/
│   ├── SettingsNavigation.vue    # Left sidebar navigation (shared between personal/admin)
│   ├── LegacySettingsForm.vue    # Renders legacy ISettings HTML with script loading
│   └── DeclarativeForm.vue       # Renders declarative forms (reuse existing DeclarativeSection.vue)
└── composables/
    └── useSettings.ts            # Settings data fetching logic (API calls, error handling)

Phase 3: Vue Router Configuration

File: src/router/routes.ts (add to existing routes array)

Note: Follow existing pattern from apps/users routes. Default sections match routes.php:
- Personal: 'personal-info' (from routes.php line 51)
- Admin: 'server' (from routes.php line 52, not 'overview')

const routes: RouteConfig[] = [
  // ... existing routes (users, apps) ...
  {
    path: '/:index(index.php/)?settings/user/:section?',
    name: 'personal-settings',
    components: {
      default: PersonalSettings,
      navigation: SettingsNavigation
    },
    props: { default: route => ({ section: route.params.section || 'personal-info' }) }
  },
  {
    path: '/:index(index.php/)?settings/admin/:section?',
    name: 'admin-settings',
    components: {
      default: AdminSettings,
      navigation: SettingsNavigation
    },
    props: { default: route => ({ section: route.params.section || 'server' }) }
  }
]

Router initialization (in src/router/index.ts):
- Already exists and handles base URL, history mode
- Just add new routes to existing routes array
- Router sync with Vuex already configured in main-apps-users-management.ts

Phase 4: New API Endpoints

Strategy:
- Initial load: Use InitialState (like AppSettingsController) - provides sections + initial content
- Navigation: Use API endpoints for subsequent section loads
- Reuse existing DeclarativeSettingsController patterns where possible

Modify apps/settings/appinfo/routes.php:

// New API routes for SPA (add to 'routes' array)
['name' => 'SettingsApi#getSection', 'url' => '/settings/api/section/{type}/{section}', 'verb' => 'GET'],
// Note: Consider extending DeclarativeSettingsController instead of new controller

New controller: lib/Controller/SettingsApiController.php:

class SettingsApiController extends OCSController {
    use CommonSettingsTrait;  // Reuse existing formatting logic

    public function __construct(
        string $appName,
        IRequest $request,
        // Inject same dependencies as PersonalSettingsController/AdminSettingsController
        ISettingsManager $settingsManager,
        IUserSession $userSession,
        IDeclarativeManager $declarativeManager,
        IGroupManager $groupManager,
        ISubAdmin $subAdmin,
        // ... other dependencies
    ) {
        parent::__construct($appName, $request);
        // Initialize trait properties
    }

    /**
     * Returns complete section data for SPA navigation
     * Combines sections, content, and navigation in one response
     */
    public function getSection(string $type, string $section): JSONResponse {
        $user = $this->userSession->getUser();
        if ($user === null) {
            throw new NotLoggedInException();
        }

        // Validate type
        if (!in_array($type, ['personal', 'admin'])) {
            return new JSONResponse(['error' => 'Invalid type'], Http::STATUS_BAD_REQUEST);
        }

        // Check permissions for admin
        if ($type === 'admin') {
            $settings = $this->settingsManager->getAllowedAdminSettings($section, $user);
            $declarative = $this->declarativeManager->getFormsWithValues($user, $type, $section);
            if (empty($settings) && empty($declarative)) {
                return new JSONResponse(['error' => 'Access denied'], Http::STATUS_FORBIDDEN);
            }
        }

        // Get sections for navigation
        $sections = $type === 'personal'
            ? $this->formatPersonalSections($type, $section)
            : $this->formatAdminSections($type, $section);

        // Get declarative forms
        $this->declarativeManager->loadSchemas();
        $declarativeSettings = $this->declarativeManager->getFormsWithValues($user, $type, $section);
        
        // Sanitize sensitive values
        foreach ($declarativeSettings as &$form) {
            foreach ($form['fields'] as &$field) {
                if (isset($field['sensitive']) && $field['sensitive'] === true && !empty($field['value'])) {
                    $field['value'] = 'dummySecret';
                }
            }
        }

        // Get legacy ISettings HTML
        if ($type === 'personal') {
            $legacySettings = array_values($this->settingsManager->getPersonalSettings($section));
        } else {
            $legacySettings = array_values($this->settingsManager->getAllowedAdminSettings($section, $user));
        }

        $legacyHtml = '';
        $requiredScripts = [];
        foreach ($legacySettings as $setting) {
            if ($setting instanceof ISettings) {
                $form = $setting->getForm();
                $legacyHtml .= $form->renderAs('')->render();
                // Extract required scripts from form (if available)
                // Note: This may need custom implementation per ISettings
            }
        }

        // Get active section info
        $activeSection = $this->settingsManager->getSection($type, $section);
        $sectionInfo = null;
        if ($activeSection) {
            $sectionInfo = [
                'id' => $activeSection->getID(),
                'name' => $activeSection->getName(),
                'type' => $type
            ];
        }

        return new JSONResponse([
            'sections' => $sections,  // For navigation
            'content' => [
                'declarative' => $declarativeSettings,
                'legacyHtml' => $legacyHtml,
                'scripts' => $requiredScripts  // Array of script URLs/paths
            ],
            'sectionInfo' => $sectionInfo,
            'navigation' => [
                'personal' => $this->formatPersonalSections($type, $section),
                'admin' => $this->formatAdminSections($type, $section)
            ]
        ]);
    }
}

Phase 5: Modify Existing Controllers

Strategy:
- Add feature flag check: if SPA enabled, use empty template + InitialState
- Otherwise, fall back to existing frame.php template
- Follow AppSettingsController.viewApps() pattern exactly

File: lib/Controller/PersonalSettingsController.php

public function index(string $section): TemplateResponse {
    $config = \OC::$server->get(IConfig::class);
    $spaEnabled = $config->getSystemValueBool('settings_spa_enabled', false);
    
    if (!$spaEnabled) {
        // Fall back to existing behavior
        return $this->getIndexResponse('personal', $section);
    }

    $user = $this->userSession->getUser();
    assert($user !== null, 'No user logged in for settings');

    // Load schemas
    $this->declarativeSettingsManager->loadSchemas();
    
    // Get sections for navigation
    $personalSections = $this->formatPersonalSections('personal', $section);
    $adminSections = $this->formatAdminSections('personal', $section);
    
    // Get initial section content (same logic as getIndexResponse but return data)
    $declarativeSettings = $this->declarativeSettingsManager->getFormsWithValues($user, 'personal', $section);
    foreach ($declarativeSettings as &$form) {
        foreach ($form['fields'] as &$field) {
            if (isset($field['sensitive']) && $field['sensitive'] === true && !empty($field['value'])) {
                $field['value'] = 'dummySecret';
            }
        }
    }
    
    $settings = array_values($this->settingsManager->getPersonalSettings($section));
    $settings = array_merge(...$settings);
    
    // Format legacy HTML
    $legacyHtml = '';
    foreach ($settings as $setting) {
        if ($setting instanceof ISettings) {
            $form = $setting->getForm();
            $legacyHtml .= $form->renderAs('')->render();
        }
    }

    // Provide all data via InitialState for SPA (like AppSettingsController)
    $this->initialState->provideInitialState('settingsType', 'personal');
    $this->initialState->provideInitialState('currentSection', $section);
    $this->initialState->provideInitialState('sections', [
        'personal' => $personalSections,
        'admin' => $adminSections
    ]);
    $this->initialState->provideInitialState('sectionContent', [
        'declarative' => $declarativeSettings,
        'legacyHtml' => $legacyHtml,
        'scripts' => []  // Will be populated if needed
    ]);

    // Set navigation entry
    if ($section === 'theming') {
        $this->navigationManager->setActiveEntry('accessibility_settings');
    } else {
        $this->navigationManager->setActiveEntry('settings');
    }

    // Use empty template - Vue takes over
    Util::addScript('settings', 'vue-settings-spa');  // Match webpack entry naming
    Util::addStyle('settings', 'settings');
    
    $activeSection = $this->settingsManager->getSection('personal', $section);
    $pageTitle = $activeSection ? $activeSection->getName() : $this->l10n->t('Personal settings');
    
    return new TemplateResponse('settings', 'settings/empty', [
        'pageTitle' => $pageTitle
    ]);
}

Same pattern for AdminSettingsController (use 'admin' type, check admin permissions).

Phase 6: Handle Legacy ISettings

Legacy settings return TemplateResponse with HTML. Options:

Option A: Render HTML server-side, inject into Vue (RECOMMENDED FOR MVP)
- API returns pre-rendered HTML
- Vue component uses v-html to display
- Scripts loaded dynamically with proper ordering
- Security: Sanitize HTML before injection
- Consider iframe sandbox for complete isolation

Option B: Convert legacy to declarative (long-term)
- Gradually migrate ISettings to declarative forms
- More work but cleaner architecture
- Better performance and maintainability

Recommended: Option A first, then gradually migrate to Option B.

Critical Considerations:
1. Script loading order matters - some legacy forms depend on specific load order
2. Event handlers may expect specific DOM state - ensure DOM is ready
3. CSS scoping conflicts - use scoped styles or CSS modules
4. Security: Always sanitize HTML before v-html (use DOMPurify or similar)
5. Error handling: Legacy forms may fail - show graceful error messages

<!-- LegacySettingsForm.vue -->
<template>
  <div class="legacy-settings-form">
    <NcLoadingIcon v-if="loading" :size="32" />
    <div 
      v-if="error" 
      class="error-message"
      v-text="error"
    />
    <div 
      v-if="htmlContent && !loading && !error"
      ref="container"
      v-html="sanitizedHtml"
      class="legacy-content"
    />
  </div>
</template>

<script lang="ts">
import { Component, Vue, Prop } from 'vue-property-decorator'
import NcLoadingIcon from '@nextcloud/vue/components/NcLoadingIcon'

@Component({
  components: {
    NcLoadingIcon
  }
})
export default class LegacySettingsForm extends Vue {
  @Prop({ required: true }) htmlContent!: string
  @Prop({ default: () => [] }) scripts!: string[]
  
  loading = true
  error: string | null = null
  sanitizedHtml = ''

  async mounted() {
    try {
      // Sanitize HTML (use DOMPurify or Nextcloud's sanitizer)
      this.sanitizedHtml = this.sanitizeHtml(this.htmlContent)
      
      // Wait for next tick to ensure DOM is ready
      await this.$nextTick()
      
      // Load scripts in order
      for (const script of this.scripts) {
        await this.loadScript(script)
      }
      
      // Trigger any initialization that legacy forms might need
      this.$nextTick(() => {
        // Some legacy forms may need window events or initialization
        this.$emit('loaded')
      })
      
      this.loading = false
    } catch (err) {
      console.error('Failed to load legacy settings form', err)
      this.error = this.$t('settings', 'Failed to load settings form')
      this.loading = false
    }
  }

  sanitizeHtml(html: string): string {
    // Use Nextcloud's HTML sanitizer or DOMPurify
    // This is critical for security
    // TODO: Find Nextcloud's sanitization utility
    return html  // Placeholder - MUST implement proper sanitization
  }

  loadScript(src: string): Promise<void> {
    return new Promise((resolve, reject) => {
      // Check if script already loaded
      const existing = document.querySelector(`script[src="${src}"]`)
      if (existing) {
        resolve()
        return
      }

      const script = document.createElement('script')
      script.src = src
      script.async = false  // Maintain order
      script.onload = () => resolve()
      script.onerror = () => reject(new Error(`Failed to load script: ${src}`))
      document.head.appendChild(script)
    })
  }
}
</script>

<style scoped>
.legacy-settings-form {
  position: relative;
  min-height: 200px;
}

.error-message {
  color: var(--color-error);
  padding: 1rem;
}

.legacy-content {
  /* Ensure legacy forms don't break layout */
  overflow: auto;
}
</style>

Phase 7: Build Configuration

IMPORTANT: Settings app currently uses Webpack (legacy build system), not Vite.
Entry point naming convention: 'vue-settings-*' (matches existing pattern)

Modify build/frontend-legacy/webpack.modules.cjs:

settings: {
  // ... existing entries ...
  'vue-settings-spa': path.join(__dirname, 'apps/settings/src', 'main-settings.ts'),
  // ... rest of entries
}

Note: Consider migrating to Vite in future, but for now use Webpack to match existing codebase.

Entry point file: apps/settings/src/main-settings.ts

Follow pattern from main-apps-users-management.ts:
- Import Vue, Vue Router, Vuex, Pinia
- Set up CSP nonce
- Initialize router with routes
- Sync Vuex store with router
- Mount to #content element

 Phase 8: Template Changes

 File: templates/settings/empty.php (already exists, minimal changes)

 <?php
 // Empty template - Vue SPA takes over #content
 style('settings', 'settings');
 ?>

File Modification Summary

| File                                          | Action | Purpose                              |
|-----------------------------------------------|--------|--------------------------------------|
| src/main-settings.ts                          | Create | SPA entry point (TypeScript)         |
| src/SettingsApp.vue                            | Create | Root Vue component (reuse pattern) |
| src/router/routes.ts                           | Modify | Add new routes to existing array    |
| src/store/settings-store.ts                    | Create | Pinia store for caching             |
| src/views/PersonalSettings.vue                 | Create | Personal settings container          |
| src/views/AdminSettings.vue                    | Create | Admin settings container             |
| src/views/SettingsSection.vue                 | Create | Generic section renderer             |
| src/components/SettingsNavigation.vue          | Create | Shared navigation component          |
| src/components/LegacySettingsForm.vue         | Create | Legacy HTML renderer                |
| src/composables/useSettings.ts                 | Create | API fetching composable              |
| lib/Controller/SettingsApiController.php       | Create | API endpoints (or extend existing)  |
| lib/Controller/PersonalSettingsController.php  | Modify | Add SPA mode with feature flag      |
| lib/Controller/AdminSettingsController.php     | Modify | Add SPA mode with feature flag      |
| lib/Controller/CommonSettingsTrait.php          | Modify | Extract reusable methods if needed |
| appinfo/routes.php                              | Modify | Add API routes                       |
| build/frontend-legacy/webpack.modules.cjs       | Modify | Add vue-settings-spa entry         |

Migration Strategy

1. Parallel operation: Keep old frame.php working, new SPA optional via flag
2. Feature flag: 'settings_spa_enabled' => true in config.php
   - Can be enabled per-instance for testing
   - Default: false (opt-in)
3. Gradual rollout: 
   - Start with Personal Settings (fewer legacy forms)
   - Then Admin Settings
   - Test with specific sections first
4. Backwards compatible: Legacy ISettings still work via HTML injection
5. Rollback plan: Feature flag can disable SPA instantly if issues arise
6. A/B testing: Can compare performance between old and new implementations

Performance Optimizations:
- Cache section data in Pinia store (avoid refetching on navigation)
- Prefetch adjacent sections in background
- Lazy load heavy legacy forms
- Debounce rapid navigation clicks

Testing Plan

Functional Testing:
1. Navigation between sections (no page reload)
2. Browser back/forward buttons (with query params)
3. Direct URL access to sections (deep linking)
4. Legacy ISettings forms render and work correctly
5. Declarative forms render and save
6. Permission checks (admin-only sections, sub-admin restrictions)
7. Mobile responsiveness
8. Error handling (API failures, network errors)
9. Loading states during navigation
10. Form validation errors display correctly
11. CSRF token handling for API calls
12. Feature flag toggle (enable/disable SPA mode)

Edge Cases:
1. Legacy ISettings with complex JavaScript dependencies
2. Legacy forms that modify DOM structure dynamically
3. Forms with file uploads
4. Forms requiring password confirmation
5. Concurrent navigation (rapid clicking)
6. Browser refresh during form editing
7. Network interruption during save
8. Invalid section IDs in URL
9. Permission changes while viewing settings

Performance Testing:
1. Initial load time vs old implementation
2. Navigation speed (should be instant)
3. Memory usage (check for leaks)
4. Bundle size impact
5. Cache effectiveness (section data caching)

Upstream Contribution Notes

Code Quality:
- Follow Nextcloud coding standards (PSR-12 for PHP, ESLint for JS/TS)
- Use TypeScript for new Vue components (matches existing codebase)
- Add unit tests for new API endpoints (PHPUnit)
- Add integration tests for Vue components (Jest/Vitest)
- Add E2E tests for critical flows (Cypress if available)
- Update PHPDoc comments for all new methods
- Add JSDoc comments for TypeScript functions

Documentation:
- Update developer documentation for new API endpoints
- Document feature flag usage
- Add migration guide for other apps using ISettings
- Update CHANGELOG.md

PR Process:
- Create PR against master branch (or appropriate version branch)
- Reference any related GitHub issues
- Include screenshots/videos of new functionality
- Ensure CI/CD passes (PHPUnit, ESLint, TypeScript checks)
- Get code review from Nextcloud maintainers
- Address feedback iteratively

Future Improvements (Post-MVP):
- Migrate to Vite build system
- Gradually convert legacy ISettings to declarative forms
- Add section-level caching with invalidation
- Implement optimistic UI updates for form saves
- Add keyboard navigation improvements

Estimated Scope

- Phase 1: 1 day (setup + feature branch)
- Phase 2: 3-4 days (Vue app structure, components, store)
- Phase 3: 1-2 days (router integration)
- Phase 4: 3-4 days (API endpoints, error handling)
- Phase 5: 2-3 days (controller modifications, feature flag)
- Phase 6: 4-5 days (legacy ISettings handling, script loading, security)
- Phase 7: 1 day (build configuration)
- Phase 8: 1 day (template changes)
- Testing: 4-5 days (comprehensive testing including edge cases)

Total: ~3-4 weeks for MVP with legacy support

Additional Considerations:
- Documentation updates: 1-2 days
- Code review and refactoring: 2-3 days
- Performance optimization: 1-2 days

Risk Factors:
- Legacy ISettings complexity may extend Phase 6 timeline
- Script loading issues may require additional debugging
- Security review for HTML sanitization

Technical Notes

Initial State vs API Strategy:
- Initial load: Use InitialState (like AppSettingsController.viewApps())
  - Provides sections + initial section content
  - Avoids extra API call on first load
  - Matches existing Nextcloud patterns
- Subsequent navigation: Use API endpoints
  - Fetch new section content via SettingsApiController
  - Cache in Pinia store to avoid refetching
  - Handle loading states and errors gracefully

State Management:
- Use Pinia for settings state (cache sections, content)
- Use Vuex for router sync (already configured)
- Store structure:
  - sections: { personal: [], admin: [] }
  - content: { [type-section]: { declarative, legacyHtml, scripts } }
  - loading: { [type-section]: boolean }
  - errors: { [type-section]: string }

Error Handling:
- API failures: Show user-friendly error messages
- Network errors: Retry logic with exponential backoff
- Invalid sections: Redirect to default section
- Permission errors: Show appropriate message, redirect if needed
- Legacy form errors: Display in form context

Security Considerations:
- Sanitize all HTML before v-html injection (critical!)
- Validate section IDs and types on backend
- CSRF tokens for all POST requests
- XSS prevention in legacy HTML rendering
- Content Security Policy compliance

Performance Optimizations:
- Cache section data in Pinia store
- Prefetch adjacent sections on hover/focus
- Lazy load legacy forms (only when section is active)
- Debounce rapid navigation
- Use requestAnimationFrame for DOM updates
- Minimize re-renders with Vue's reactivity system

Browser Compatibility:
- Test on Chrome, Firefox, Safari, Edge
- Ensure Vue Router history mode works with all browsers
- Handle browser back/forward correctly
- Test on mobile browsers (iOS Safari, Chrome Mobile)